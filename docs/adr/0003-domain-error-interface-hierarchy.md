---
status: accepted
date: 2026-02-13
---

# ADR-0003: ドメインエラーインターフェース階層

> 遡及的に記録

## コンテキスト

本プロジェクトでは`lockfile`、`pnpm`、`store`の各パッケージがそれぞれ固有のエラーを発生させる。
呼び出し側がエラーの種類に応じて適切に処理するためには、エラーの型を判別できる仕組みが必要だった。

Goの標準的な`error`インターフェースでは型情報が失われやすく、`errors.Is`/`errors.As`での判別にも限界がある。
各ドメインのエラーを型安全に扱い、コンパイル時に網羅性を保証できる仕組みが求められた。

## 検討した選択肢

### 選択肢1: ドメイン固有のエラーインターフェース

各ドメインパッケージに`XxxErrorIF`インターフェースを定義し具象エラー型がこれを実装する。
共通の`BaseError`構造体を埋め込みファクトリ関数`NewXxxError()`で生成する。

#### 良い点

- 関数の戻り値型でドメインが明確になる（`LockfileErrorIF`を返す関数はlockfile関連のエラーしか返さない）
- コンパイル時インターフェースチェック（`var _ IF = (*Concrete)(nil)`）で実装漏れを防げる
- `BaseError`による共通実装の再利用

#### 悪い点

- Go標準のエラーハンドリングパターンから逸脱する
- 各エラー型に`Error()`/`Is()`/`As()`のボイラープレートが必要

### 選択肢2: 標準errorインターフェースのみ

`error`を返し、`errors.Is`/`errors.As`で型判別する。

#### 良い点

- Go標準のイディオムに準拠
- ボイラープレートが少ない

#### 悪い点

- 関数シグネチャからどの種類のエラーが返りうるか読み取れない
- 型の網羅性がコンパイル時に保証されない

### 選択肢3: sentinel errors

パッケージレベルの変数（`var ErrNotFound = errors.New("not found")`）でエラーを定義する。

#### 良い点

- シンプル
- `errors.Is`で比較可能

#### 悪い点

- エラーに追加情報（メッセージ、原因）を持たせにくい
- 型による分岐ができない

## 決定

各ドメインパッケージに固有のエラーインターフェース（`LockfileErrorIF`、`PnpmErrorIF`、`StoreErrorIF`）を定義し、`common.BaseError`を埋め込んだ具象エラー型で実装する。
エラー生成は必ずファクトリ関数`NewXxxError()`を通す。

このパターンにより、関数シグネチャが「このパッケージからどんなエラーが返りうるか」をドキュメントとして機能し、コンパイル時のインターフェースチェックで実装の正しさを保証できる。

## 結果

### 良い影響

- エラーの種類が型レベルで明確になり、呼び出し側が適切なハンドリングを行える
- 新しいエラー型を追加する際のパターンが統一されている

### 悪い影響

- 新しいエラー型ごとに`Error()`/`Is()`/`As()`のボイラープレートコードが必要
- Go標準のエラーパターンに慣れた開発者には学習コストがある