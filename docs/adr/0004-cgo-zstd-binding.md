---
status: accepted
date: 2026-02-13
---

# ADR-0004: CGo経由でのC zstdライブラリ使用

> 遡及的に記録

## コンテキスト

pnpm fetcher v3以降では、pnpmストアをzstd圧縮のtarballとしてパッケージングする必要がある。
Nixpkgsの再現可能ビルドの要件として、生成されるtarballは`tar --sort=name --mtime="@315532800" --owner=0 --group=0 --numeric-owner --zstd`コマンドの出力と「バイト単位で同一」でなければならない。

このバイト同一性の要件を満たすためには、zstd圧縮の出力がCLIの`zstd`コマンド（C参照実装ベース）と完全に一致する必要がある。

## 検討した選択肢

### 選択肢1: CGo経由でC zstdライブラリ（libzstd）を使用

`ZSTD_compressStream2` APIをCGo経由で直接呼び出す。
圧縮レベル3、コンテンツチェックサム有効化、コンテンツサイズフラグ無効化、マルチスレッドモード（nbWorkers=1）など、CLIの挙動を完全に再現するパラメータを設定する。

#### 良い点

- C参照実装そのものを使うため、バイト同一性を保証できる
- CLIの内部挙動（パイプ入力時のコンテンツサイズ省略、マルチスレッドモードのコードパス）を正確に再現可能

#### 悪い点

- `CGO_ENABLED=1`が必須
- `pkg-config`と`libzstd`の開発ヘッダーがビルド環境に必要
- クロスコンパイルが困難

### 選択肢2: Pure GoのZstd実装（klauspost/compress/zstd）

`github.com/klauspost/compress/zstd`はGoで書かれたzstd互換の圧縮ライブラリ。

#### 良い点

- CGo不要でビルドが単純
- クロスコンパイルが容易

#### 悪い点

- C参照実装とバイト同一の出力でない
- フレームヘッダーの構成、ストリーミング時のバッファリング挙動、マルチスレッドモードのセマンティクスなどが異なる

### 選択肢3: 外部コマンドとしてzstd/tarを呼び出し

`os/exec`で`tar --zstd`コマンドを実行する。

#### 良い点

- バイト同一性が保証される（同じコマンドを使うため）
- 実装が単純

#### 悪い点

- ランタイムに`tar`と`zstd`のインストールが必要

## 決定

CGo経由でC zstdライブラリ（libzstd）を使用する。

バイト同一性はNixpkgsの再現可能ビルドにおいて必須要件であり、妥協できない。
Pure Go実装ではこの要件を満たせない。
外部コマンド呼び出しはバイト同一性を満たせるが、外部コマンドへの暗黙的な依存が生じる。

CGo依存によるビルド環境の複雑化は、Nix Flakes（`nix develop`）やmiseによる開発環境の提供で軽減している。

## 結果

### 良い影響

- Nixpkgsのfetcher v3+と完全に互換性のあるバイト同一のtarballを生成できる

### 悪い影響

- ビルドに`CGO_ENABLED=1`、`pkg-config`、`libzstd`が必須となり、開発環境のセットアップが複雑になる
- クロスコンパイルが事実上不可能